# -------------------------------------------------------------
# \file   build-windows-mingw.yml
# \author Jens Kallup - paule32.jk
# \legal  (c) 2026 all rights reserved.
#
# \nore   builds remote bootcd.iso file for IBM-PC compatibles
# -------------------------------------------------------------
name: Build Boot ISO (Windows / MSYS2 MinGW32)

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

permissions:
  contents: write

env:
  SRC_DIR: src
  ISO_PATH: build/bin/bootcd.iso
  ARTIFACT_CD_NAME: bootCD-iso

jobs:
  BootISO:              # interne ID (ohne Leerzeichen)
    name: Boot-CD ISO   # Anzeige-Name (mit Leerzeichen ok)
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup MSYS2 (MinGW32 toolchain + required tools)
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW32
          update: true
          install: >
            mingw-w64-i686-gcc
            mingw-w64-i686-binutils
            mingw-w64-i686-gdb
            make
            nasm
            xorriso
            python
            wget
            gzip
            gawk
            coreutils
            diffutils
            file
            git

      - name: Show tool versions
        shell: msys2 {0}
        run: |
          set -euxo pipefail
          gcc --version
          g++ --version
          ld --version || true
          objcopy --version
          make --version
          nasm -v
          xorriso -version
          python3 --version
          wget --version | head -n 1
          dd --version | head -n 1
          awk --version | head -n 1
          
      - name: Build-CD in MSYS2
        shell: msys2 {0}
        run: |
          set -euxo pipefail
          ls
          make AUTO_YES=1

      - name: Verify ISO exists
        shell: msys2 {0}
        run: |
          set -euxo pipefail
          ls   -la  build/bin
          test -f   "${ISO_PATH}"
          ls   -la  "${ISO_PATH}"

      - name: Upload Artifact (bootCD.iso)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_CD_NAME }}
          path: ${{ env.ISO_PATH }}
          if-no-files-found: error
      
      # 1) Zeitstempel-Tag (Berlin-Zeit) erzeugen + pushen
      - name: Create & push timestamp tag (vYYYY_mm_dd_HH_mm)
        shell: msys2 {0}
        run: |
          set -euxo pipefail

          export TZ=Europe/Berlin
          TAG="$(date +v%Y_%m_%d_%H_%M)"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Kollision vermeiden (z.B. Re-Run in derselben Minute)
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} existiert bereits. Bitte erneut starten (nächste Minute) oder Format erweitern."
            exit 1
          fi

          git tag -a "${TAG}" -m "Automated build ${TAG}"
          git push origin "${TAG}"

          echo "RELEASE_TAG=${TAG}" >> "$GITHUB_ENV"

      # 2) Release erstellen + ISO anhängen
      - name: Create GitHub Release + upload bootcd.iso
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "$env:RELEASE_TAG"
          if (-not $tag) { throw "RELEASE_TAG missing" }

          gh --version
          gh release create $tag "${{ env.ISO_PATH }}" `
            --title $tag `
            --generate-notes
          
      - name: Verify email recipient is set
        shell: pwsh
        env:
          NOTIFY_TO_EMAIL: ${{ secrets.NOTIFY_TO_EMAIL }}
        run: |
          if ([string]::IsNullOrWhiteSpace($env:NOTIFY_TO_EMAIL)) {
            throw "Secret NOTIFY_TO_EMAIL is missing/empty. Set it in Repo Settings -> Secrets and variables -> Actions."
          }
          
      # 3) E-Mail nur bei Erfolg (nach erfolgreichem Release)
      - name: Send email (success)
        if: success()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}   # z.B. 465 oder 587
          secure: false                           # 465 meist true; bei 587 ggf. false
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}

          to: ${{ secrets.NOTIFY_TO_EMAIL }}
          from: "GitHub Actions <${{ secrets.SMTP_USERNAME }}>"
          subject: "✅ Boot ISO Release erstellt: ${{ env.RELEASE_TAG }}"
          body: |
            Build & Release erfolgreich

            Repo:  ${{ github.repository }}
            Tag:   ${{ env.RELEASE_TAG }}
            ISO:   ${{ env.ISO_PATH }}

            Run:   https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
      
      - name: Send IRC notification (NickServ)
        shell: pwsh
        env:
          IRC_SERVER: irc.eu.libera.chat
          IRC_PORT: "6667"
          IRC_NICK: dBaseBot
          IRC_USER: dBaseBot
          IRC_CHAN: "#dBase.de"
          IRC_PASS: ${{ secrets.IRC_PASS }}
        run: |
          $server = $env:IRC_SERVER
          $port   = [int]$env:IRC_PORT
          $nick   = $env:IRC_NICK
          $user   = $env:IRC_USER
          $chan   = $env:IRC_CHAN
          $pass   = $env:IRC_PASS
          if([string]::IsNullOrWhiteSpace($pass)) { throw "IRC_PASS fehlt (GitHub Secret)!" }

          $tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("W. Europe Standard Time")
          $berlin = [System.TimeZoneInfo]::ConvertTimeFromUtc([DateTime]::UtcNow, $tz)
          $stamp  = "v{0:yyyy-MM-dd_HH:mm}" -f $berlin
          
          $msg = "✅ New Release created: $stamp"

          $client = [System.Net.Sockets.TcpClient]::new()
          $client.Connect($server, $port)
          $stream = $client.GetStream()
          $reader = [System.IO.StreamReader]::new($stream)
          $writer = [System.IO.StreamWriter]::new($stream)
          $writer.NewLine = "`r`n"
          $writer.AutoFlush = $true

          function Send-Line([string]$s){
            Write-Host "IRC > $s"
            $writer.WriteLine($s)
          }

          Send-Line "NICK $nick"
          Send-Line "USER $user 0 * :GitHub Release Bot"

          $identified = $false
          $joined = $false
          $deadline = (Get-Date).AddSeconds(35)

          while((Get-Date) -lt $deadline){
            if(-not $stream.DataAvailable){
              Start-Sleep -Milliseconds 120
              continue
            }

            $line = $reader.ReadLine()
            if($null -eq $line) { break }
            Write-Host "IRC < $line"

            # PING/PONG
            if($line -match '^PING :(.*)$'){
              Send-Line "PONG :$($Matches[1])"
              continue
            }

            # Welcome -> jetzt NickServ IDENTIFY
            if($line -match " 001 $nick "){
              Send-Line "PRIVMSG NickServ :IDENTIFY $pass"
              continue
            }

            # Viele Services melden so etwas (Text variiert je nach Network)
            if($line -match '(identified|You are now identified|SASL authentication successful|now recognized)'){
              $identified = $true
              Send-Line "JOIN $chan"
              continue
            }

            # Falls der Server nicht explizit bestätigt, nach kurzem Warten trotzdem joinen
            if(-not $identified -and $line -match "NickServ"){
              # nichts erzwingen, nur weiter lesen
              continue
            }

            # JOIN bestätigt -> dann Nachricht senden
            if($line -match "JOIN :?$([regex]::Escape($chan))"){
              $joined = $true
              Send-Line "PRIVMSG $chan :$msg"
              break
            }

            # Harte Fehler sichtbar machen
            if($line -match " 4\d\d " -or $line -match " 5\d\d "){
              throw "IRC Fehler: $line"
            }

            # Wenn wir schon länger warten und keine Identify-Bestätigung kommt:
            if(-not $identified -and (Get-Date) -gt $deadline.AddSeconds(-20)){
              # Versuch: trotzdem JOIN (manche Netze bestätigen Identify nicht klar)
              $identified = $true
              Send-Line "JOIN $chan"
            }
          }

          Send-Line "QUIT :bye"
          $reader.Dispose(); $writer.Dispose(); $stream.Dispose(); $client.Close()

          if(-not $joined){
            throw "Keine JOIN-Bestätigung erhalten -> Nachricht evtl. nie gesendet. Siehe Log."
          }
