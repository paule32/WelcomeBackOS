# -------------------------------------------------------------
# \file   build-windows-mingw.yml
# \author Jens Kallup - paule32.jk
# \legal  (c) 2026 all rights reserved.
#
# \nore   builds remote bootcd.iso file for IBM-PC compatibles
# -------------------------------------------------------------
name: Build Boot ISO (Windows / MSYS2 MinGW32)

on:
    push:
        branches: [ "main", "master" ]
    workflow_dispatch:

permissions:
    contents: write

env:
    SRC_DIR: src
    
    ISO_PATH: build/bin/bootcd.iso
    USB_PATH: build/bin/bootusb.img
    
    ARTIFACT_CD_NAME: bootCD-iso
    ARTIFACT_USB_NAME: bootUSB-iso

jobs:
    # -----------------------------------
    # grundsystem auf windows erstelln...
    # -----------------------------------
    BootISO_CD:             # interne ID (ohne Leerzeichen)
        name: Boot-CD ISO   # Anzeige-Name (mit Leerzeichen ok)
        runs-on: windows-latest
        steps:
            - name: Checkout Windows
              uses: actions/checkout@v4
              with:
                fetch-depth: 0

            - name: Setup MSYS2 (MinGW32 toolchain + required tools)
              uses: msys2/setup-msys2@v2
              with:
                msystem: MINGW32
                update: true
                install: >
                    mingw-w64-i686-gcc
                    mingw-w64-i686-binutils
                    mingw-w64-i686-gdb
                    make
                    nasm
                    xorriso
                    python
                    wget
                    gzip
                    gawk
                    coreutils
                    diffutils
                    file
                    git

            - name: Show tool versions
              shell: msys2 {0}
              run: |
                set -euxo pipefail
                gcc --version
                g++ --version
                ld --version || true
                objcopy --version
                make --version
                nasm -v
                xorriso -version
                python3 --version
                wget --version | head -n 1
                dd --version | head -n 1
                awk --version | head -n 1
              
            - name: Build-CD in MSYS2
              shell: msys2 {0}
              run: |
                set -euxo pipefail
                ls
                make AUTO_YES=1

            - name: Verify ISO exists
              shell: msys2 {0}
              run: |
                set -euxo pipefail
                ls   -la  build/bin
                test -f   "${ISO_PATH}"
                ls   -la  "${ISO_PATH}"

            - name: Upload Artifact (bootCD.iso)
              uses: actions/upload-artifact@v4
              with:
                name: ${{ env.ARTIFACT_CD_NAME }}
                path: ${{ env.ISO_PATH }}
                if-no-files-found: error
          
            # 1) Zeitstempel-Tag (Berlin-Zeit) erzeugen + pushen
            - name: Create & push timestamp tag (vYYYY_mm_dd_HH_mm)
              shell: msys2 {0}
              run: |
                set -euxo pipefail
                
                export TZ=Europe/Berlin
                TAG="$(date +v%Y_%m_%d_%H_%M)"
                
                git config user.name  "github-actions[bot]"
                git config user.email "github-actions[bot]@users.noreply.github.com"
                
                # Kollision vermeiden (z.B. Re-Run in derselben Minute)
                if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
                    echo "Tag ${TAG} existiert bereits. Bitte erneut starten (nächste Minute) oder Format erweitern."
                    exit 1
                fi
                
                git tag -a "${TAG}" -m "Automated build ${TAG}"
                git push origin "${TAG}"
                
                echo "RELEASE_TAG=${TAG}" >> "$GITHUB_ENV"

            # 2) Release erstellen + ISO anhängen
            - name: Create GitHub Release + upload bootcd.iso
              shell: pwsh
              env:
                GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                $tag = "$env:RELEASE_TAG"
                if (-not $tag) { throw "RELEASE_TAG missing" }
                
                gh --version
                gh release create $tag "${{ env.ISO_PATH }}" `
                --title $tag `
                --generate-notes
      
            - name: Verify email recipient is set
              shell: pwsh
              env:
                NOTIFY_TO_EMAIL: ${{ secrets.NOTIFY_TO_EMAIL }}
              run: |
                if ([string]::IsNullOrWhiteSpace($env:NOTIFY_TO_EMAIL)) {
                    throw "Secret NOTIFY_TO_EMAIL is missing/empty. Set it in Repo Settings -> Secrets and variables -> Actions."
                }

            # 3) E-Mail nur bei Erfolg (nach erfolgreichem Release)
            - name: Send email (when success)
              if: success()
              uses: dawidd6/action-send-mail@v3
              with:
                server_address: ${{ secrets.SMTP_SERVER }}
                server_port: ${{ secrets.SMTP_PORT }}   # z.B. 465 oder 587
                secure: false                           # 465 meist true; bei 587 ggf. false
                username: ${{ secrets.SMTP_USERNAME }}
                password: ${{ secrets.SMTP_PASSWORD }}
        
                to: ${{ secrets.NOTIFY_TO_EMAIL }}
                from: "GitHub Actions <${{ secrets.SMTP_USERNAME }}>"
                subject: "✅ Boot ISO Release erstellt: ${{ env.RELEASE_TAG }}"
                body: |
                  Build & Release erfolgreich
                  
                  Repo:  ${{ github.repository }}
                  Tag:   ${{ env.RELEASE_TAG }}
                  ISO:   ${{ env.ISO_PATH }}
                  Run:   https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

            - name: Send IRC notification (NickServ)
              shell: pwsh
              env:
                IRC_SERVER: irc.eu.libera.chat
                IRC_PORT: "6667"
                IRC_NICK: dBaseBot
                IRC_USER: dBaseBot
                IRC_PASS: ${{ secrets.IRC_PASS }}
                
                IRC_CHAN_DE: "#dBase.de"
                IRC_CHAN_EN: "#dBase"
              run: |
                $server = $env:IRC_SERVER
                $port   = [int]$env:IRC_PORT
                $nick   = $env:IRC_NICK
                $user   = $env:IRC_USER
                $pass   = $env:IRC_PASS
                
                if([string]::IsNullOrWhiteSpace($pass)) {
                    throw "IRC_PASS fehlt (GitHub Secret)!"
                }
                
                $chanDE = $env:IRC_CHAN_DE
                $chanEN = $env:IRC_CHAN_EN
                
                # Europe/Berlin Zeitstempel: yyyy-mm-dd_HH:mm
                $tz     = [System.TimeZoneInfo]::FindSystemTimeZoneById("W. Europe Standard Time")
                $berlin = [System.TimeZoneInfo]::ConvertTimeFromUtc([DateTime]::UtcNow, $tz)
                
                $stamp  = "v{0:yyyy-MM-dd_HH:mm}" -f $berlin
                $url    = "https://github.com/paule32/WelcomeBackOS"
                
                $msgDE = "✅ Neues Release erfolgreich erstellt, und veröffentlicht: $stamp - $url"
                $msgEN = "✅ New Release created, and published successfully: $stamp - $url"
                
                $client = [System.Net.Sockets.TcpClient]::new()
                $client.Connect($server, $port)
                $stream = $client.GetStream()
                $reader = [System.IO.StreamReader]::new($stream)
                $writer = [System.IO.StreamWriter]::new($stream)
                $writer.NewLine = "`r`n"
                $writer.AutoFlush = $true
                
                function Send-Line([string]$s) {
                    Write-Host "IRC > $s"
                    $writer.WriteLine($s)
                }
                
                Send-Line "NICK $nick"
                Send-Line "USER $user 0 * :GitHub Release Bot"
                
                $identified = $false
                $joinedDE   = $false
                $joinedEN   = $false
                
                $deadline   = (Get-Date).AddSeconds(45)
                
                while ((Get-Date) -lt $deadline) {
                    if (-not $stream.DataAvailable) {
                        Start-Sleep -Milliseconds 120
                        continue
                    }
                    
                    $line = $reader.ReadLine()
                    if ($null -eq $line) { break }
                    Write-Host "IRC < $line"
                    
                    # PING/PONG
                    if ($line -match '^PING :(.*)$') {
                        Send-Line "PONG :$($Matches[1])"
                        continue
                    }
                    
                    # Welcome -> jetzt NickServ IDENTIFY
                    if ($line -match " 001 $nick " -and -not $identified) {
                        Send-Line "PRIVMSG NickServ :IDENTIFY $pass"
                        continue
                    }
                    
                    # Viele Services melden so etwas (Text variiert je nach Network)
                    if ($line -match '(identified|You are now identified|SASL authentication successful|now recognized)') {
                        $identified = $true
                        Send-Line "JOIN $chanDE"
                        Send-Line "JOIN $chanEN"
                        continue
                    }
                    
                    if (-not $identified -and $line -match '(identified|You are now identified|now recognized|SASL authentication successful)') {
                        $identified = $true
                        Send-Line "JOIN $chanDE"
                        Send-Line "JOIN $chanEN"
                        continue
                    }
                    
                    # Fallback: manche Netze bestätigen Identify nicht eindeutig -> nach kurzer Zeit trotzdem joinen
                    if(-not $identified -and (Get-Date) -gt $deadline.AddSeconds(-30)){
                        $identified = $true
                        Send-Line "JOIN $chanDE"
                        Send-Line "JOIN $chanEN"
                    }
                    
                    if ($line -match "JOIN :?$([regex]::Escape($chanDE))") { $joinedDE = $true }
                    if ($line -match "JOIN :?$([regex]::Escape($chanEN))") { $joinedEN = $true }
                    
                    # JOIN bestätigt -> dann Nachricht senden
                    # Sobald wir (mind.) den jeweiligen Join haben, senden wir die passende Sprache
                    if ($joinedDE -and $msgDE) {
                        Send-Line "PRIVMSG $chanDE :$msgDE"
                        $msgDE = $null
                    }
                    if ($joinedEN -and $msgEN) {
                        Send-Line "PRIVMSG $chanEN :$msgEN"
                        $msgEN = $null
                    }
                    
                    # Harte Fehler sichtbar machen
                    if ($line -match " 4\d\d " -or $line -match " 5\d\d ") {
                        throw "IRC Fehler: $line"
                    }
                    
                    # Wenn wir schon länger warten und keine Identify-Bestätigung kommt:
                    if (-not $identified -and (Get-Date) -gt $deadline.AddSeconds(-20)) {
                        # Versuch: trotzdem JOIN (manche Netze bestätigen Identify nicht klar)
                        $identified = $true
                        Send-Line "JOIN $chanDE"
                    }
                    
                    if(($joinedDE  -or [string]::IsNullOrEmpty($env:IRC_CHAN_DE)) -and
                        ($joinedEN -or [string]::IsNullOrEmpty($env:IRC_CHAN_EN)) -and
                        ($null -eq $msgDE) -and ($null -eq $msgEN)){
                        break
                    }
                }
                
                Send-Line "QUIT :bye"
                $reader.Dispose(); $writer.Dispose(); $stream.Dispose(); $client.Close()
    
    # -----------------------------------
    # für Verwendung von Linux-Tools ...
    # -----------------------------------
    BootImageUSB:             # interne ID (ohne Leerzeichen)
        name: Boot-USB Image  # Anzeige-Name (mit Leerzeichen ok)
        runs-on: ubuntu-latest
        needs: BootISO_CD
        steps:
            - name: Create USB image on Linux
              uses: actions/checkout@v4
            
            - name: Setup Linux Environment
              run: |
                sudo apt-get update
                sudo apt-get install -y syslinux-utils xorriso
                
            - name: Download bootcd.iso artifact
              uses: actions/download-artifact@v4
              with:
                name: ${{ env.ARTIFACT_CD_NAME }}
                path: ${{ env.ISO_PATH }}
            
            - name: Convert CD to USB iso image BIOS
              run: |
                rm -rf build/bin/bootusb_bios.img
                ls -la
                cp build/bin/bootcd.iso build/bin/bootusb_bios.img
                ls -la build/bin/
                isohybrid build/bin/bootusb_bios.img
            
            - name: Convert CD to USB iso image UEFI
              run: |
                rm -rf build/bin/bootusb_uefi.img
                ls -la
                cp build/bin/bootcd.iso build/bin/bootusb_uefi.img
                ls -la build/bin
                isohybrid --uefi build/bin/bootusb_uefi.img
            
            - name: Convert CD to USB iso image GPT + EFI
              run: |
                rm -rf build/bin/bootusb_gpt.img
                ls -la
                cp build/bin/bootcd.iso build/bin/bootusb_gpt.img
                ls -la build/bin
                isohybrid --uefi --gpt build/bin/bootusb_gpt.img
            
            - name: Upload packed outputs
              uses: actions/upload-artifact@v4
              with:
                name: ${{ env.ARTIFACT_USB_NAME }}
                path: |
                    build/bin/bootcd.iso
                    build/bin/bootusb_bios.img
                    build/bin/bootusb_uefi.img
                    build/bin/bootusb_gpt.img
 