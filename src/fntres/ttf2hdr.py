# ttf2hdr.py
#
# Requires: pip install pillow
#
# Usage example:
#   python3 ttf2hdr.py \
#       --ttf font.ttf \
#       --w 8 --h 16   \
#       --pt 16        \
#       --out font.h

import argparse
from PIL import Image, ImageDraw, ImageFont

def render_glyph(font: ImageFont.FreeTypeFont, ch: str, w: int, h: int, threshold: int) -> list[int]:
    """
    Render one glyph into w*h bitmap and pack each row into one byte (MSB=left).
    Returns list of length h, each element is 0..255.
    """
    img = Image.new("L", (w, h), 0)
    d = ImageDraw.Draw(img)

    # Bounding box of glyph at origin
    # We place baseline using font metrics; for monospace it's typically fine.
    ascent, descent = font.getmetrics()

    # Try to vertically align: top at 0, baseline at ascent-1
    # Using anchor "la" (left, baseline) if available; fallback manual.
    try:
        d.text((0, ascent - 1), ch, fill=255, font=font, anchor="ls")
    except TypeError:
        # fallback: draw at y=0 and hope metrics fit
        d.text((0, 0), ch, fill=255, font=font)

    # Convert to 1-bit via threshold
    px = img.load()
    rows = []
    for y in range(h):
        b = 0
        for x in range(w):
            bit = 1 if px[x, y] >= threshold else 0
            b = (b << 1) | bit  # MSB left
        # if w < 8, shift to MSB alignment; if w > 8, you'd need more bytes
        if w < 8:
            b <<= (8 - w)
        rows.append(b & 0xFF)
    return rows

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--ttf", required=True, help="Path to .ttf font file (prefer monospace)")
    ap.add_argument("--w", type=int, default=8, help="Glyph cell width in pixels (default 8)")
    ap.add_argument("--h", type=int, default=16, help="Glyph cell height in pixels (default 16)")
    ap.add_argument("--pt", type=int, default=16, help="Font size in points (try = h)")
    ap.add_argument("--threshold", type=int, default=128, help="0..255 threshold for 1-bit")
    ap.add_argument("--out", default="font8x16.h", help="Output header file")
    ap.add_argument("--name", default="", help="Base name, default auto from w/h, e.g. font8x16")
    args = ap.parse_args()

    w, h = args.w, args.h
    if w > 8:
        raise SystemExit("This simple packer supports w<=8 (1 byte per row). Use w<=8 or extend to multi-byte rows.")

    font = ImageFont.truetype(args.ttf, size=args.pt)

    name = args.name.strip() or f"font{w}x{h}"
    out = args.out

    # Build 256 glyphs (0..255). 0..31 control chars will be blank.
    table = []
    for code in range(256):
        ch = chr(code)
        # Make control chars blank
        if code < 32:
            rows = [0] * h
        else:
            rows = render_glyph(font, ch, w, h, args.threshold)
        table.append(rows)

    with open(out, "w", encoding="utf-8") as f:
        f.write("// Auto-generated by ttf2hdr.py\n")
        f.write("#pragma once\n\n")
        f.write("#include \"stdint.h\"\n\n")
        f.write(f"#define {name.upper()}_W {w}\n")
        f.write(f"#define {name.upper()}_H {h}\n\n")
        f.write(f"extern const uint8_t {name}[256][{h}];\n\n")
        f.write(f"const uint8_t {name}[256][{h}] = {{\n")
        for code in range(256):
            f.write(f"    /* {code:3d} 0x{code:02X} */ {{")
            f.write(", ".join(f"0x{b:02X}" for b in table[code]))
            f.write("},\n")
        f.write("};\n")

    print(f"Wrote {out} as {name}[256][{h}] ({w}x{h})")

if __name__ == "__main__":
    main()
