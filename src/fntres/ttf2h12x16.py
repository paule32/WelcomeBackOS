#!/usr/bin/env python3
# ttf2hdr_12x16.py
#
# Requires: pip install pillow
#
# Example:
#   py -3.13 ttf2hdr_12x16.py --ttf DejaVuSansMono.ttf --out font12x16.h
#
# Output:
#   const uint8_t font12x16[256][16][2];

import argparse
import math
from PIL import Image, ImageDraw, ImageFont


def pack_row_bits_msb_left(bits01, bytes_per_row):
    """
    bits01: list of 0/1, length = w
    Pack bits into bytes_per_row bytes, MSB=left.
    Example w=12 => 2 bytes: [b0,b1], where b0 holds first 8 pixels.
    """
    out = []
    w = len(bits01)
    for b in range(bytes_per_row):
        byte = 0
        for i in range(8):
            x = b * 8 + i
            bit = bits01[x] if x < w else 0
            byte = (byte << 1) | (1 if bit else 0)
        out.append(byte & 0xFF)
    return out


def render_glyph(font, ch, w, h, threshold, xoff, yoff):
    """
    Render glyph into w*h grayscale, threshold -> 1-bit,
    then pack each row into bytes_per_row bytes.
    """
    img = Image.new("L", (w, h), 0)
    d = ImageDraw.Draw(img)

    # Baseline placement:
    # Put the baseline at y = ascent-1 + yoff, left at xoff
    ascent, descent = font.getmetrics()
    try:
        d.text((xoff, ascent - 1 + yoff), ch, fill=255, font=font, anchor="ls")
    except TypeError:
        # fallback (older Pillow): approximate at yoff
        d.text((xoff, yoff), ch, fill=255, font=font)

    px = img.load()
    bytes_per_row = (w + 7) // 8
    rows = []

    for y in range(h):
        bits01 = [1 if px[x, y] >= threshold else 0 for x in range(w)]
        rows.append(pack_row_bits_msb_left(bits01, bytes_per_row))

    return rows  # h x bytes_per_row


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--ttf", required=True, help="Path to .ttf font file (prefer monospace)")
    ap.add_argument("--w", type=int, default=12, help="Glyph width (default 12)")
    ap.add_argument("--h", type=int, default=16, help="Glyph height (default 16)")
    ap.add_argument("--pt", type=int, default=16, help="Font size in points (start: =h)")
    ap.add_argument("--threshold", type=int, default=128, help="0..255 threshold for 1-bit")
    ap.add_argument("--xoff", type=int, default=0, help="X offset inside cell (pixels)")
    ap.add_argument("--yoff", type=int, default=0, help="Y offset inside cell (pixels)")
    ap.add_argument("--name", default="font12x16", help="C array base name")
    ap.add_argument("--out", default="font12x16.h", help="Output header file")
    args = ap.parse_args()

    w, h = args.w, args.h
    bytes_per_row = (w + 7) // 8

    font = ImageFont.truetype(args.ttf, size=args.pt)

    table = []
    for code in range(256):
        if code < 32:
            rows = [[0] * bytes_per_row for _ in range(h)]
        else:
            rows = render_glyph(font, chr(code), w, h, args.threshold, args.xoff, args.yoff)
        table.append(rows)

    with open(args.out, "w", encoding="utf-8") as f:
        f.write("// Auto-generated by ttf2hdr_12x16.py\n")
        f.write("#pragma once\n\n")
        f.write("#include \"stdint.h\"\n\n")
        f.write(f"#define {args.name.upper()}_W {w}\n")
        f.write(f"#define {args.name.upper()}_H {h}\n")
        f.write(f"#define {args.name.upper()}_BPR {bytes_per_row}  // bytes per row\n\n")
        f.write(f"extern const uint8_t {args.name}[256][{h}][{bytes_per_row}];\n\n")
        f.write(f"const uint8_t {args.name}[256][{h}][{bytes_per_row}] = {{\n")

        for code in range(256):
            f.write(f"    /* {code:3d} 0x{code:02X} */ {{\n")
            for y in range(h):
                rowbytes = table[code][y]
                f.write("        {")
                f.write(", ".join(f"0x{b:02X}" for b in rowbytes))
                f.write("},\n")
            f.write("    },\n")

        f.write("};\n")

    print(f"Wrote {args.out}: {args.name}[256][{h}][{bytes_per_row}] ({w}x{h})")


if __name__ == "__main__":
    main()
